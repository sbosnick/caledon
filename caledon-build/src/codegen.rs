// Copyright 2020 Steven Bosnick
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE-2.0 or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use std::io::Write;

use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};

use crate::{
    model::{Arg, Interface, Message, Protocol},
    Error, Result,
};

use doc::format_short_doc;
use interface::generate_interface;
use message::{generate_event, generate_request};
use protocol::generate_protocol;

mod doc;
mod interface;
mod message;
mod protocol;

pub fn generate_code<'a, W, I>(mut file: W, protocols: I) -> Result<()>
where
    W: Write,
    I: Iterator<Item = &'a Protocol> + Clone + 'a,
{
    writeln!(
        file,
        "// File generated by caledon-build from the following input files:"
    )
    .map_err(Error::file_write)?;
    for protocol in protocols.clone() {
        writeln!(file, "//     {}", protocol.path().display()).map_err(Error::file_write)?;
    }
    let requests_ident = format_ident!("Requests");
    let events_ident = format_ident!("Events");
    let protocol_family = generate_protocol_family(
        protocols.clone(),
        requests_ident.clone(),
        events_ident.clone(),
    );
    let protocol_family_request_messages =
        generate_pf_request_messages(protocols.clone(), requests_ident);
    let protocol_family_event_messages =
        generate_pf_event_messages(protocols.clone(), events_ident);
    let modules = protocols.map(generate_protocol);

    let output = quote! {
        use crate::core::{Interface, FromOpcodeError, MessageHandler, MessageList, MessageMaker, OpCode, ProtocolFamily, ProtocolFamilyMessageList};

        #protocol_family

        #protocol_family_request_messages

        #protocol_family_event_messages

        #(#modules)*
    };

    write!(file, "{}", output).map_err(Error::file_write)
}

fn generate_protocol_family<'a, I>(
    protocols: I,
    requests_ident: Ident,
    events_ident: Ident,
) -> TokenStream
where
    I: Iterator<Item = &'a Protocol> + Clone + 'a,
{
    let entries = protocols.clone().map(generate_protocol_list_entry);
    let request_has_fd_entries = generate_has_fd_entries(protocols.clone(), requests_ident.clone());
    let event_has_fd_entries = generate_has_fd_entries(protocols.clone(), events_ident.clone());
    let make_request_message_entries =
        generate_make_message_entries(protocols.clone(), requests_ident.clone(), |p| {
            p.protocol_requests_ident()
        });
    let make_event_message_entries =
        generate_make_message_entries(protocols, events_ident.clone(), |p| {
            p.protocol_events_ident()
        });

    quote! {
            #[doc = "The list of protocols implemented by caledon."]
            #[derive(Debug, PartialEq)]
            pub enum Protocols {
                #(#entries,)*
            }

            impl ProtocolFamily for Protocols {
                type Requests = #requests_ident;

                type Events = #events_ident;

                fn request_has_fd(&self, opcode: OpCode) -> bool {
                    match self {
                        #(#request_has_fd_entries)*
                    }
                }

                fn event_has_fd(&self, opcode: OpCode) -> bool {
                    match self {
                        #(#event_has_fd_entries)*
                    }
                }

                fn make_request_message<MM>(&self, opcode: OpCode, msg: MM) -> Result<Self::Requests, FromOpcodeError<MM::Error>>
                where
                    MM: MessageMaker,
                {
                    match self {
                        #(#make_request_message_entries)*
                    }
                }

                fn make_event_message<MM>(&self, opcode: OpCode, msg: MM) -> Result<Self::Events, FromOpcodeError<MM::Error>>
                where
                    MM: MessageMaker,
                {
                    match self {
                        #(#make_event_message_entries)*
                    }
                }
            }

    }
}

fn generate_pf_request_messages<'a, I>(protocols: I, ident: Ident) -> TokenStream
where
    I: Iterator<Item = &'a Protocol> + Clone + 'a,
{
    generate_pf_message_list(
        protocols,
        ident,
        &"requests",
        generate_family_request_entry,
        |i| i.requests(),
        |p| p.protocol_requests_ident(),
    )
}

fn generate_pf_event_messages<'a, I>(protocols: I, ident: Ident) -> TokenStream
where
    I: Iterator<Item = &'a Protocol> + Clone + 'a,
{
    generate_pf_message_list(
        protocols,
        ident,
        &"events",
        generate_family_event_entry,
        |i| i.events(),
        |p| p.protocol_events_ident(),
    )
}

fn generate_pf_message_list<'a, I, F, G, H, M, MI>(
    protocols: I,
    ident: Ident,
    doc_word: &str,
    generate_family_entry: F,
    get_interface_messages: G,
    get_messages_ident: H,
) -> TokenStream
where
    I: Iterator<Item = &'a Protocol> + Clone + 'a,
    F: Fn(&Protocol) -> TokenStream,
    G: Fn(&'a Interface) -> MI + 'a,
    H: Fn(&'a Protocol) -> Ident + 'a,
    M: Message,
    MI: Iterator<Item = M> + 'a,
{
    let enum_doc = format!(
        "The list of the {} associated with the protocols implemented by caledon.",
        doc_word
    );
    let entries = protocols.clone().map(generate_family_entry);
    let handle_entries = generate_handler_entries(
        protocols,
        ident.clone(),
        get_interface_messages,
        get_messages_ident,
    );

    quote! {
            #[doc = #enum_doc]
            #[derive(Debug, PartialEq)]
            pub enum #ident {
                #(#entries,)*
            }

            impl ProtocolFamilyMessageList for #ident {
                type ProtocolFamily = Protocols;

                fn handle_message<MH: MessageHandler>(&self, mut handler: MH) -> Result<(), MH::Error> {
                    match self {
                        #(#handle_entries,)*
                        _ => panic!("Unrecognized message dispatched to handle message!"),
                    }
                }
            }

    }
}

fn generate_protocol_list_entry(protocol: &Protocol) -> TokenStream {
    let entry = protocol.enum_entry_ident();
    let mod_ident = protocol.mod_ident();
    let entry_doc = format_short_doc(protocol, |name| format!("The {} protocol.", name));

    quote! {
        #[doc = #entry_doc]
        #entry(#mod_ident::Protocol)
    }
}

fn generate_family_request_entry(protocol: &Protocol) -> TokenStream {
    let entry = protocol.enum_entry_ident();
    let mod_ident = protocol.mod_ident();
    let request_ident = protocol.protocol_requests_ident();
    let entry_doc = format_short_doc(protocol, |name| {
        format!("The requests for the {} protocol.", name)
    });

    quote! {
        #[doc = #entry_doc]
        #entry(#mod_ident::#request_ident)
    }
}

fn generate_family_event_entry(protocol: &Protocol) -> TokenStream {
    let entry = protocol.enum_entry_ident();
    let mod_ident = protocol.mod_ident();
    let event_ident = protocol.protocol_events_ident();
    let entry_doc = format_short_doc(protocol, |name| {
        format!("The events for the {} protocol.", name)
    });

    quote! {
        #[doc = #entry_doc]
        #entry(#mod_ident::#event_ident)
    }
}

fn generate_handler_entries<'a, I, F, G, M, MI>(
    iter: I,
    ident: Ident,
    f: F,
    g: G,
) -> impl Iterator<Item = TokenStream> + 'a
where
    I: Iterator<Item = &'a Protocol> + 'a,
    F: Fn(&'a Interface) -> MI + 'a,
    G: Fn(&'a Protocol) -> Ident + 'a,
    M: Message,
    MI: Iterator<Item = M> + 'a,
{
    iter.flat_map(move |p| {
        let penum_entry = p.enum_entry_ident();
        let pmod = p.mod_ident();
        let pmlist_entry = g(p);
        p.interfaces().map(move |i| (penum_entry.clone(), pmod.clone(), pmlist_entry.clone(), i))
    })
    .flat_map(move |(penum_entry, pmod, pmlist_entry, i)| {
        let imod = i.mod_ident();
        let ienum_entry = i.enum_entry_ident();
        f(i).map(move |m| (penum_entry.clone(), pmod.clone(), pmlist_entry.clone(), imod.clone(), ienum_entry.clone(), m))
    }).map(move |(penum_entry, pmod, pmlist_entry, imod, ienum_entry, m)| {
        let menum_entry = m.enum_entry_ident();
        quote! {
            #ident::#penum_entry(self::#pmod::#pmlist_entry::#ienum_entry(self::#pmod::#imod::#ident::#menum_entry(msg))) => handler.handle(msg)
        }
    })
}

fn generate_has_fd_entries<'a, I>(iter: I, ident: Ident) -> impl Iterator<Item = TokenStream> + 'a
where
    I: Iterator<Item = &'a Protocol> + 'a,
{
    iter.flat_map(move |p| {
        let penum_entry = p.enum_entry_ident();
        let pmod = p.mod_ident();
        p.interfaces().map(move |i| (penum_entry.clone(), pmod.clone(),  i))
    }).map(move |(penum_entry, pmod,  i)| {
        let ienum_entry = i.enum_entry_ident();
        let iface = i.interface_ident();

        quote! {
            Protocols::#penum_entry(self::#pmod::Protocol::#ienum_entry(_)) => <self::#pmod::#iface as Interface>::#ident::has_fd(opcode),
        }
    })
}

fn generate_make_message_entries<'a, I, F>(
    iter: I,
    ident: Ident,
    f: F,
) -> impl Iterator<Item = TokenStream> + 'a
where
    I: Iterator<Item = &'a Protocol> + 'a,
    F: Fn(&Protocol) -> Ident + 'a,
{
    iter.flat_map(move |p| {
        let penum_entry = p.enum_entry_ident();
        let pmod = p.mod_ident();
        let pmessage = f(p);
        p.interfaces()
            .map(move |i| (penum_entry.clone(), pmod.clone(), pmessage.clone(), i))
    })
    .map(move |(penum_entry, pmod, pmessage, i)| {
        let ienum_entry = i.enum_entry_ident();
        let iface = i.interface_ident();

        quote! {
            Protocols::#penum_entry(self::#pmod::Protocol::#ienum_entry(_)) => {
                <self::#pmod::#iface as Interface>::#ident::from_opcode(opcode, msg).map(|m| {
                    #ident::#penum_entry(#pmod::#pmessage::#ienum_entry(m))
                })
            }
        }
    })
}

fn generate_new_param(arg: &Arg) -> TokenStream {
    let arg_type = generate_arg_type(arg);
    let param_name = arg.param_ident();

    quote! {
        #param_name: #arg_type
    }
}

fn generate_arg_type(arg: &Arg) -> TokenStream {
    match arg.type_name() {
        "new_id" | "object" => quote! { ObjectId },
        "int" => quote! { i32 },
        "uint" => quote! { u32 },
        "fixed" => quote! { Decimal },
        "string" => quote! { CString },
        "array" => quote! { Box<[u8]> },
        "fd" => quote! { Fd },
        _ => panic!(
            "Encountered an unexpected argument type: {}",
            arg.type_name()
        ),
    }
}
