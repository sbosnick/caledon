// Copyright 2020 Steven Bosnick
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE-2.0 or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use std::io::Write;

use proc_macro2::TokenStream;
use quote::quote;

use crate::{model::Protocol, Error, Result};

pub fn generate_code<'a, W, I>(mut file: W, protocols: I) -> Result<()>
where
    W: Write,
    I: Iterator<Item = &'a Protocol> + Clone,
{
    writeln!(
        file,
        "// File generated by caledon-build from the following input files:"
    )
    .map_err(Error::file_write)?;
    for protocol in protocols.clone() {
        writeln!(file, "//     {}", protocol.path().display()).map_err(Error::file_write)?;
    }

    let entries = protocols.clone().map(generate_protocol_list_entries);
    let modules = protocols.map(generate_protocol);

    let output = quote! {
        use crate::core::{ProtocolFamily, ProtocolList};

        #[doc = "The family of protocols implement by caledon."]
        pub struct Family;

        impl ProtocolFamily for Family {
            type Protocols = Protocols;
        }

        #[doc = "The list of protocols implemented by caledon."]
        pub enum Protocols {
            #(#entries,)*
        }

        impl ProtocolList for Protocols {
            type ProtocolFamily = Family;
        }

        #(#modules)*
    };

    write!(file, "{}", output).map_err(Error::file_write)
}

fn generate_protocol(protocol: &Protocol) -> TokenStream {
    let mod_ident = protocol.mod_ident();
    let protocol_ident = protocol.protocol_ident();
    let mod_doc = protocol.description().map_or_else(
        || format!("caledon types for {} protocol", protocol.name()),
        |desc| {
            let mut s = desc.summary().to_owned();
            if let Some(detail) = desc.detail() {
                s += "\n";
                s += detail;
            }
            s
        },
    );
    let protocol_doc = format!("The {} protocol.", protocol.name());

    quote! {
        #[doc = #mod_doc]
        pub mod #mod_ident {
            #[doc = #protocol_doc]
            pub struct #protocol_ident;
        }
    }
}

fn generate_protocol_list_entries(protocol: &Protocol) -> TokenStream {
    let entry = protocol.enum_entry_ident();
    let mod_ident = protocol.mod_ident();
    let protocol_ident = protocol.protocol_ident();
    let entry_doc = protocol.description().map_or_else(
        || format!("The {} protocol.", protocol.name()),
        |desc| desc.summary().to_owned(),
    );

    quote! {
        #[doc = #entry_doc]
        #entry(#mod_ident::#protocol_ident)
    }
}
